# A Serf's Up file

require 'log4r'

# Set up a general logger for the app
logger = Log4r::Logger.new 'my_logger'
logger.outputters = Log4r::FileOutputter.new(
  'fileOutputter',
  filename: 'console.txt')

# Define a single emitter w/ default redis connections
emitter = Serf::RedisEmitter.new

# Define a group of events handlers
group :events do
  # We use the EmRunner middleware so the handlers get run in the
  # EventMachine deferred thread pool.
  use Serf::Middleware::EmRunner, logger: logger

  # Define a handler for the post_rated_event kind of message.
  handle 'post_rated_event', proc { |env|
    logger.info("I'm in post_rated_event #{env.inspect}")
    [200, {}, '']
  }

  # Define what happens if a message received has a 'kind' attribute that
  # is not defined in this group.
  not_found(proc { |env|
    logger.info("event not found #{env.inspect}")
    [200, {},'']
  })
end

# Define a group of handlers that'll be handled by the MsgPackReceiver
group :commands do
  # We use the EmRunner middleware so the handlers get run in the
  # EventMachine deferred thread pool.
  use Serf::Middleware::EmRunner, logger: logger

  # Handle the 'post_rating_request' command message.
  handle 'post_rating_request', proc { |env|
    logger.info("I'm in post_rating_request #{env.inspect}")
    emitter.emit(
      kind: 'post_rated_event',
      rated_data: env.to_s)
    [200, {},'']
  }
  not_found(proc { |env|
    logger.info("command not found #{env.inspect}")
    [200, {},'']
  })
end

# Bind our receivers and handler groups
bind :events, Serf::RedisPubsubReceiver
bind :commands, Serf::MsgpackReceiver, :host => '0.0.0.0', :post => 18800


